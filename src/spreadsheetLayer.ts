/* eslint-disable @typescript-eslint/no-unused-vars */

// Generated by Copilot
import { LayerManager, Color, EOE, SpaceTimeController, ELL} from "@wwtelescope/engine";
import { MarkerScales, CoordinatesType, AltUnits } from "@wwtelescope/engine-types";
import { useWindowsLineEndings } from "./utils";
import { AsteroidDefinition } from "./asteroid_elements";
// Shows a single 3D point as a spreadsheet/table layer in the given frame.
// Inputs are AU in the *conventional* ecliptic XYZ sense (X,Y,Z as Horizons reports).
//
// Internally, WWT uses Vector3d(x, z, y) (a Y/Z swap) for its ecliptic-ish space coords,
// so we write table columns such that the rendered point matches the ELL convention.
//
// Usage:
//   const p = show3dPoint(-1.397, 5.001, 0.010, { name: "Jup@epoch", frame: "Sun" });
//   p.update(-1.4, 5.0, 0.01);
//
// If you already have meters, use p.updateMeters(x_m, y_m, z_m) instead.
interface Show3dPointOpts {
  frame?: string;
  name?: string;
  pointSize?: number;
  colorHex?: string;
  
  // NEW:
  // - "horizons": inputs are conventional (x,y,z) like Horizons reports (default)
  // - "wwt": inputs are already WWT-internal (x, zStd, yStd) like ELL.calculateRectangularJD returns
  inputConvention?: "horizons" | "wwt";
  
  // Optional: perihelion longitude (deg) for comparison logging
  perihelionLon?: number;
};

export function show3dPoint(xau: number, yau: number, zau: number, opts: Show3dPointOpts = {}) {

  const frame = opts.frame ?? "Sun";
  const name = opts.name ?? "Debug 3D Point";
  const pointSize = opts.pointSize ?? 25; // tweak as desired
  const inputConvention = opts.inputConvention ?? "horizons";

  // Verbose logging removed - use comparePositions() for diagnostics

  // Generated by Copilot
  // Fail fast if the target frame isn't registered. Otherwise the layer can end up in an unexpected
  // context and look "rotated" relative to other solar-system content.
  const maps = LayerManager.get_allMaps?.() as unknown as Record<string, unknown> | undefined;
  if (!maps || !maps[frame]) {
    throw new Error(
      `Frame '${frame}' is not registered in LayerManager. ` +
      `If this is a custom child frame, register it first (e.g. renderFrameAsChild(...)).`
    );
  }
  
  function normalizeXYZ(x: number, y: number, z: number): [number, number, number] {
    // SpreadSheetLayer will do (X,Z,Y) internally.
    // If the caller is already providing WWT-internal coords, pre-swap to cancel it.
    if (inputConvention === "wwt") {
      return [x, z, y];
    }
    return [x, y, z];
  }
  

  // AU -> km conversion is what SpreadSheetLayer expects when astronomical=true and cartesianScale=1:
  // xyzScale = getScaleFactor(cartesianScale, ...) / (1000*149598000)
  // If cartesianScale is AltUnits.AstronomicalUnits (6), getScaleFactor returns (1000*149598000),
  // so xyzScale becomes 1 AU in engine units.
  //
  // Therefore: put AU values directly in the columns, set cartesianScale=6 (AU),
  // coordinatesType=1 (Cartesian), and astronomical=true.
  function csvForAU(xAU: number, yAU: number, zAU: number) {
    // Columns must start with x/y/z (SpreadSheetLayer.guessHeaderAssignments looks for that)
    // We provide both "y" and "z" explicitly.
    const [x, y, z] = normalizeXYZ(xAU, yAU, zAU);
    
    return useWindowsLineEndings(["name,x,y,z", `${name},${x},${y},${z}`].join("\n"));
  }

  // Create layer via LayerManager helper so it appears in UI tree.
  const layer = LayerManager.createSpreadsheetLayer(frame, name, csvForAU(xau, yau, zau));

  // Force Cartesian XYZ mode and AU scaling.
  // coordinatesType: 1 => Cartesian (see spreadsheet_layer.js logic)
  // layer.set_referenceFrame('Sun');
  layer.set_coordinatesType(CoordinatesType.rectangular);
  layer.set_xAxisColumn(1);
  layer.set_yAxisColumn(2);
  layer.set_zAxisColumn(3);

  // AltUnits: 6 => AU (see getScaleFactor switch in spreadsheet_layer.js)
  layer.set_cartesianScale(AltUnits.astronomicalUnits);

  // Make it visible and obvious.
  layer.astronomical = true;       // important: enables AU scaling path
  layer.enabled = true;
  layer.set_opacity(1);
  layer.set_markerScale(MarkerScales.screen);
  layer.set_scaleFactor(pointSize * 2);
  layer.set_color(Color.fromHex(opts?.colorHex ?? "#ff00e6"));
  
  
  // make the layer a child of the Sun
  

  // Provide an easy updater.
  const api = {
    layer,

    update(xAU, yAU, zAU) {
      // Updating via updateData() will reparse the single row.
      layer.updateData(csvForAU(xAU, yAU, zAU), false, true, true);
      return api;
    },

    // Convenience if you have meters (like from ELL.calculateRectangularJD output):
    // Convert meters -> AU and call update().
    updateMeters(xM, yM, zM) {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      const AU_M = 149597870700;
      return api.update(xM / AU_M, yM / AU_M, zM / AU_M);
    },

    remove() {
      // safest remove path
      LayerManager.deleteLayerByID(layer.id, true, true);
    }
  };

  return api;
}

import { asteroidDefinition2EOE } from "./asteroid_elements";
import { calculatePerihelionLon } from "./orbitComparison";
import { AU_KM } from "./constants";
/* eslint-disable @typescript-eslint/naming-convention */

export function show3dPerihelion(objectDefinition: AsteroidDefinition, colorHex = "#00aaff") {
  const eoe = asteroidDefinition2EOE(objectDefinition);
  console.log('Spreadsheet-layer perihelion EOE:', eoe);
  console.log(`Asteroid ${objectDefinition.name} perihelion calculation:`);
  const ellPos = ELL.calculateRectangularJD(objectDefinition.epoch, eoe);
  show3dPoint(ellPos.x, ellPos.y, ellPos.z, {
    name: objectDefinition.name + " Perihelion",
    frame: "Sun",
    pointSize: 25,
    colorHex: colorHex,
    inputConvention: "wwt",

  });



}