// Generated by Copilot
// Clean comparison of WWT Planet position, Custom Orbit position, and Horizons reference

import { ELL, EOE, Planets, SpaceTimeController } from "@wwtelescope/engine";
import { AU_KM } from "./constants";

// Format a number
const fmt = (n: number, d = 2) => n.toFixed(d);

// Vector magnitude
const mag = (x: number, y: number, z: number) => Math.sqrt(x * x + y * y + z * z);

// Cartesian to spherical (returns degrees for lon/lat, AU for r)
function cartesianToSpherical(x: number, y: number, z: number): { lon: number; lat: number; r: number } {
  const r = mag(x, y, z);
  const lat = Math.asin(z / r) * 180 / Math.PI;
  const lon = Math.atan2(y, x) * 180 / Math.PI;
  return { lon, lat, r };
}

/**
 * Generated by Copilot
 * Compute orbital pole (angular momentum direction) from orbital elements.
 * Returns unit vector in STANDARD ecliptic coordinates.
 */
export function computeOrbitalPole(omega_deg: number, i_deg: number): { x: number; y: number; z: number } {
  const omegaRad = omega_deg * Math.PI / 180; // Ω - longitude of ascending node
  const iRad = i_deg * Math.PI / 180;         // i - inclination
  
  // H = Rz(Ω) × Rx(i) × (0, 0, 1)
  // In column-vector convention:
  // Hx = sin(Ω) * sin(i)
  // Hy = -cos(Ω) * sin(i)
  // Hz = cos(i)
  const sinO = Math.sin(omegaRad), cosO = Math.cos(omegaRad);
  const sinI = Math.sin(iRad), cosI = Math.cos(iRad);
  
  return {
    x: sinO * sinI,
    y: -cosO * sinI,
    z: cosI
  };
}

/**
 * Generated by Copilot
 * Compute perihelion direction from orbital elements.
 * Returns unit vector in STANDARD ecliptic coordinates.
 */
export function computePerihelionDirection(omega_deg: number, i_deg: number, w_deg: number): { x: number; y: number; z: number } {
  const omegaRad = omega_deg * Math.PI / 180; // Ω
  const iRad = i_deg * Math.PI / 180;         // i
  const wRad = w_deg * Math.PI / 180;         // ω
  
  const cosO = Math.cos(omegaRad), sinO = Math.sin(omegaRad);
  const cosI = Math.cos(iRad), sinI = Math.sin(iRad);
  const cosW = Math.cos(wRad), sinW = Math.sin(wRad);
  
  // P = Rz(Ω) × Rx(i) × Rz(ω) × (1, 0, 0)
  return {
    x: cosO * cosW - sinO * sinW * cosI,
    y: sinO * cosW + cosO * sinW * cosI,
    z: sinW * sinI
  };
}

/**
 * Calculate the perihelion longitude from orbital elements.
 * This is where the orbit "starts" (mean anomaly = 0).
 */
export function calculatePerihelionLon(omega: number, i: number, w: number): number {
  const omegaRad = omega * Math.PI / 180;
  const iRad = i * Math.PI / 180;
  const wRad = w * Math.PI / 180;
  
  const cosO = Math.cos(omegaRad), sinO = Math.sin(omegaRad);
  const cosI = Math.cos(iRad), sinI = Math.sin(iRad);
  
  let px = Math.cos(wRad), py = Math.sin(wRad), pz = 0;
  const py1 = py * cosI - pz * sinI;
  py = py1; pz = py * sinI + pz * cosI;
  const px2 = px * cosO - py * sinO;
  const py2 = px * sinO + py * cosO;
  px = px2; py = py2;
  
  return Math.atan2(py, px) * 180 / Math.PI;
}

export function calculatePerihelionLat(omega: number, i: number, w: number): number {
  const omegaRad = omega * Math.PI / 180;
  const iRad = i * Math.PI / 180;
  const wRad = w * Math.PI / 180;

  const cosO = Math.cos(omegaRad), sinO = Math.sin(omegaRad);
  const cosI = Math.cos(iRad), sinI = Math.sin(iRad);

  // perihelion direction in orbital plane
  let px = Math.cos(wRad), py = Math.sin(wRad), pz = 0;

  // rotate by inclination about x-axis
  const py1 = py * cosI - pz * sinI;
  const pz1 = py * sinI + pz * cosI;
  py = py1; pz = pz1;

  // rotate by Ω about z-axis
  const px2 = px * cosO - py * sinO;
  const py2 = px * sinO + py * cosO;
  px = px2; py = py2;

  // ecliptic latitude β
  const betaRad = Math.atan2(pz, Math.sqrt(px * px + py * py));
  return betaRad * 180 / Math.PI;
}

/**
 * Get the WWT built-in planet position at a given Julian Date.
 */
export function getWWTPlanetPosition(planetId: number, jd: number): { x: number; y: number; z: number } | null {
  try {
    const pos = Planets.getPlanetPositionDirect(planetId, jd);
    if (pos) {
      return { x: pos.x, y: pos.y, z: pos.z };
    }
  } catch (e) {
    console.warn("getWWTPlanetPosition failed:", e);
  }
  return null;
}

// Normalize angle to [0, 360)
const norm = (a: number) => ((a % 360) + 360) % 360;

/**
 * Main comparison function - outputs a clean summary table.
 */
export function comparePositions(
  name: string,
  eoe: EOE,
  jd: number,
  horizonsXYZ_km: { x: number; y: number; z: number },
  planetId?: number
): void {
  const currentAppJD = SpaceTimeController.get_jNow();
  
  // Horizons reference (standard ecliptic)
  const hStd = {
    x: horizonsXYZ_km.x / AU_KM,
    y: horizonsXYZ_km.y / AU_KM,
    z: horizonsXYZ_km.z / AU_KM,
  };
  const hPolar = cartesianToSpherical(hStd.x, hStd.y, hStd.z);
  
  // ELL calculation - raw WWT output
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let ellPos: any;
  try {
    ellPos = ELL.calculateRectangularJD(jd, eoe);
  } catch (e) {
    console.error("ELL.calculateRectangularJD failed:", e);
    return;
  }
  // Raw WWT coordinates
  const ellRaw = { x: ellPos.x, y: ellPos.y, z: ellPos.z };
  // Standard ecliptic (swap Y<->Z)
  const ellStd = { x: ellPos.x, y: ellPos.z, z: ellPos.y };
  const ellPolar = cartesianToSpherical(ellStd.x, ellStd.y, ellStd.z);
  
  // WWT Planet (if available)
  let planetRaw: { x: number; y: number; z: number } | null = null;
  let planetStd: { x: number; y: number; z: number } | null = null;
  let planetPolar: { lon: number; lat: number; r: number } | null = null;
  if (planetId !== undefined) {
    const planetPos = getWWTPlanetPosition(planetId, jd);
    if (planetPos) {
      planetRaw = { x: planetPos.x, y: planetPos.y, z: planetPos.z };
      planetStd = { x: planetPos.x, y: planetPos.z, z: planetPos.y };
      planetPolar = cartesianToSpherical(planetStd.x, planetStd.y, planetStd.z);
    }
  }
  
  // Perihelion
  const periLon = calculatePerihelionLon(eoe.omega, eoe.i, eoe.w);
  
  // Generated by Copilot - Output clean summary with XYZ coordinates
  console.log("");
  console.log("=".repeat(68));
  console.log("  POSITION COMPARISON: " + name);
  console.log("=".repeat(68));
  console.log("  JD: " + fmt(jd, 1) + " (epoch)  |  App JD: " + fmt(currentAppJD, 1) + " (delta: " + fmt(currentAppJD - jd, 2) + " days)");
  
  // XYZ Table (Standard Ecliptic coordinates in AU)
  console.log("-".repeat(68));
  console.log("  XYZ POSITIONS (Standard Ecliptic, AU)");
  console.log("-".repeat(68));
  console.log("  SOURCE             |      X       |      Y       |      Z");
  console.log("-".repeat(68));
  console.log("  JPL Horizons       | " + fmt(hStd.x, 6).padStart(11) + " | " + fmt(hStd.y, 6).padStart(11) + " | " + fmt(hStd.z, 6).padStart(11));
  console.log("  ELL (Y<->Z swap)   | " + fmt(ellStd.x, 6).padStart(11) + " | " + fmt(ellStd.y, 6).padStart(11) + " | " + fmt(ellStd.z, 6).padStart(11));
  if (planetStd) {
    console.log("  WWT Planet (swap)  | " + fmt(planetStd.x, 6).padStart(11) + " | " + fmt(planetStd.y, 6).padStart(11) + " | " + fmt(planetStd.z, 6).padStart(11));
  }
  
  // Raw WWT coordinates for debugging
  console.log("-".repeat(68));
  console.log("  RAW WWT COORDINATES (before swap, AU)");
  console.log("-".repeat(68));
  console.log("  ELL raw            | " + fmt(ellRaw.x, 6).padStart(11) + " | " + fmt(ellRaw.y, 6).padStart(11) + " | " + fmt(ellRaw.z, 6).padStart(11));
  if (planetRaw) {
    console.log("  WWT Planet raw     | " + fmt(planetRaw.x, 6).padStart(11) + " | " + fmt(planetRaw.y, 6).padStart(11) + " | " + fmt(planetRaw.z, 6).padStart(11));
  }
  
  // Longitude/Polar table
  console.log("-".repeat(68));
  console.log("  SPHERICAL COORDINATES");
  console.log("-".repeat(68));
  console.log("  SOURCE               |  LONGITUDE    |  FROM PERIHELION");
  console.log("-".repeat(68));
  console.log("  Perihelion (EOE)     |  " + fmt(periLon).padStart(7) + " deg  |  " + fmt(0).padStart(7) + " deg  (orbit start)");
  console.log("  JPL Horizons         |  " + fmt(hPolar.lon).padStart(7) + " deg  |  " + fmt(norm(hPolar.lon - periLon)).padStart(7) + " deg");
  console.log("  ELL calculation      |  " + fmt(ellPolar.lon).padStart(7) + " deg  |  " + fmt(norm(ellPolar.lon - periLon)).padStart(7) + " deg");
  if (planetPolar) {
    console.log("  WWT Planet builtin   |  " + fmt(planetPolar.lon).padStart(7) + " deg  |  " + fmt(norm(planetPolar.lon - periLon)).padStart(7) + " deg");
  }
  console.log("-".repeat(68));
  
  // Deltas
  const dEllH = mag(ellStd.x - hStd.x, ellStd.y - hStd.y, ellStd.z - hStd.z);
  let deltas = "  DELTAS:  |ELL-Horizons|: " + fmt(dEllH, 6) + " AU";
  if (planetStd) {
    const dPlanetH = mag(planetStd.x - hStd.x, planetStd.y - hStd.y, planetStd.z - hStd.z);
    deltas += "  |  |Planet-Horizons|: " + fmt(dPlanetH, 6) + " AU";
  }
  console.log(deltas);
  
  // Generated by Copilot - EOE parameters and mean anomaly at current time
  console.log("-".repeat(68));
  console.log("  EOE ORBITAL ELEMENTS (Input)");
  console.log("-".repeat(68));
  console.log("  a (AU):    " + fmt(eoe.a, 8));
  console.log("  e:         " + fmt(eoe.e, 8));
  console.log("  i (deg):   " + fmt(eoe.i, 6));
  console.log("  Omega:     " + fmt(eoe.omega, 6) + " deg  (longitude of ascending node)");
  console.log("  omega:     " + fmt(eoe.w, 6) + " deg  (argument of perihelion)");
  console.log("  periLon:   " + fmt(periLon, 6) + " deg  (= Omega + omega projected)");
  console.log("-".repeat(68));
  console.log("  EOE TIME PARAMETERS");
  console.log("-".repeat(68));
  console.log("  t (Tp):    " + fmt(eoe.t, 3) + " JD");
  console.log("  n:         " + fmt(eoe.n, 10) + " deg/day");
  console.log("  epoch:     " + fmt(eoe.jdEquinox, 3) + " JD");
  const mAtEpoch = eoe.n * (jd - eoe.t);
  const mAtNow = eoe.n * (currentAppJD - eoe.t);
  console.log("  M@epoch:   " + fmt(norm(mAtEpoch), 2) + " deg  (= n * (epoch - t))");
  console.log("  M@now:     " + fmt(norm(mAtNow), 2) + " deg  (= n * (now - t))");
  console.log("  delta M:   " + fmt(mAtNow - mAtEpoch, 4) + " deg  (= n * delta_t)");
  
  // Generated by Copilot - Orbital pole (angular momentum) comparison
  console.log("-".repeat(68));
  console.log("  ORBITAL POLE (Angular Momentum Direction)");
  console.log("-".repeat(68));
  
  // Compute from JPL elements (standard ecliptic)
  const poleJPL = computeOrbitalPole(eoe.omega, eoe.i);
  console.log("  From JPL elements (std ecliptic):");
  console.log("    H = (" + fmt(poleJPL.x, 6) + ", " + fmt(poleJPL.y, 6) + ", " + fmt(poleJPL.z, 6) + ")");
  
  // In WWT coords (swap Y↔Z)
  const poleJplWwt = { x: poleJPL.x, y: poleJPL.z, z: poleJPL.y };
  console.log("  In WWT coords (Y↔Z swap):");
  console.log("    H = (" + fmt(poleJplWwt.x, 6) + ", " + fmt(poleJplWwt.y, 6) + ", " + fmt(poleJplWwt.z, 6) + ")");
  
  // Compute perihelion direction
  const periDir = computePerihelionDirection(eoe.omega, eoe.i, eoe.w);
  console.log("  Perihelion direction (std ecliptic):");
  console.log("    P = (" + fmt(periDir.x, 6) + ", " + fmt(periDir.y, 6) + ", " + fmt(periDir.z, 6) + ")");
  const periDirWwt = { x: periDir.x, y: periDir.z, z: periDir.y };
  console.log("  In WWT coords (Y↔Z swap):");
  console.log("    P = (" + fmt(periDirWwt.x, 6) + ", " + fmt(periDirWwt.y, 6) + ", " + fmt(periDirWwt.z, 6) + ")");
  
  // If we have access to WWT Planet's state vectors, compute its orbital pole
  if (planetId !== undefined) {
    try {
      // Get position and velocity at two times to estimate velocity
      const dt = 0.01; // days
      const pos1 = getWWTPlanetPosition(planetId, jd);
      const pos2 = getWWTPlanetPosition(planetId, jd + dt);
      if (pos1 && pos2) {
        // Velocity in AU/day (WWT coords)
        const vel = {
          x: (pos2.x - pos1.x) / dt,
          y: (pos2.y - pos1.y) / dt,
          z: (pos2.z - pos1.z) / dt
        };
        console.log("  WWT Planet state vectors (WWT coords):");
        console.log("    r = (" + fmt(pos1.x, 6) + ", " + fmt(pos1.y, 6) + ", " + fmt(pos1.z, 6) + ") AU");
        console.log("    v = (" + fmt(vel.x, 6) + ", " + fmt(vel.y, 6) + ", " + fmt(vel.z, 6) + ") AU/day");
        
        // Angular momentum H = r × v (WWT coords)
        const hWwt = {
          x: pos1.y * vel.z - pos1.z * vel.y,
          y: pos1.z * vel.x - pos1.x * vel.z,
          z: pos1.x * vel.y - pos1.y * vel.x
        };
        const hMag = mag(hWwt.x, hWwt.y, hWwt.z);
        const hWwtUnit = { x: hWwt.x / hMag, y: hWwt.y / hMag, z: hWwt.z / hMag };
        console.log("  WWT Planet angular momentum (WWT coords, from r × v):");
        console.log("    H = (" + fmt(hWwtUnit.x, 6) + ", " + fmt(hWwtUnit.y, 6) + ", " + fmt(hWwtUnit.z, 6) + ")");
        
        // Compare
        const dotProduct = poleJplWwt.x * hWwtUnit.x + poleJplWwt.y * hWwtUnit.y + poleJplWwt.z * hWwtUnit.z;
        const angleDiff = Math.acos(Math.max(-1, Math.min(1, dotProduct))) * 180 / Math.PI;
        console.log("  Angle between JPL pole and WWT Planet pole: " + fmt(angleDiff, 4) + " deg");
        
        // Generated by Copilot - Check if negating the pole gives a better match
        const dotNegated = -poleJplWwt.x * hWwtUnit.x - poleJplWwt.y * hWwtUnit.y - poleJplWwt.z * hWwtUnit.z;
        const angleDiffNeg = Math.acos(Math.max(-1, Math.min(1, dotNegated))) * 180 / Math.PI;
        console.log("  Angle with NEGATED JPL pole:                 " + fmt(angleDiffNeg, 4) + " deg");
        
        if (angleDiff > 90) {
          console.log("  ⚠️ POLES ARE OPPOSITE - WWT may use left-handed convention or negate inclination");
        }
      }
    } catch (e) {
      console.warn("Could not compute WWT Planet angular momentum:", e);
    }
  }
  
  console.log("=".repeat(68));
  console.log("");
}

/**
 * Log orientation matrix (for debugging orbit patch) - disabled
 */
export function logPatchedOrientationMatrix(_eoe: EOE): void {
  // Removed - was too verbose
}
