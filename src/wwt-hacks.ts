/* eslint-disable @typescript-eslint/ban-ts-comment */
// Generated by Copilot
import { WWTControl } from "@wwtelescope/engine";
import { WWTGlobalState } from "@wwtelescope/engine-pinia/src/store";
import { type WWTEngineStore } from "./types";

let wwtReady = false;
export async function waitForWWTReady(store: WWTEngineStore): Promise<void> {
  // by @Carifio24
  if (wwtReady) {
    return;
  }
  return store.waitForReady().then(() => {
    WWTControl.singleton.renderOneFrame();
    wwtReady = true;
  });
}




// probably want to use CallableFunction but don't know
// how to restrict it to () => void
const addedToFrame: (()=>void)[] = [];
export function addToWWTRenderLoop(cb: () => void, preRender?: boolean) {
  // don't add the same function more than once
  if (addedToFrame.includes(cb)) return;
  if (preRender) WWTControl.singleton.renderOneFrame();
  
  const renderOneFrame = WWTControl.singleton.renderOneFrame;
  const newFrameRender = function() { 
    renderOneFrame.call(WWTControl.singleton);
    cb();
  };
  addedToFrame.push(cb);
  WWTControl.singleton.renderOneFrame = newFrameRender;
}

// drill down to where it is actually exported from (not bubbled up to the main package)

import { LayerMap } from "@wwtelescope/engine";

// from engine-pinia/src/store.ts > activeLayersList (this is not exported there)
export function _activeLayersList(wwt: WWTGlobalState): string[] {
  if (wwt.inst === null)
    throw new Error('cannot get activeLayersList without linking to WWTInstance');

  const layers: string[] = [];

  function accum(lm: LayerMap) {
    for (const layer of lm.layers) {
      layers.push(layer.id.toString());
    }
    
    for (const [_mapname, sublm] of Object.entries(lm.childMaps)) {
      accum(sublm);
    }
  }

  const rootlm = wwt.inst.lm.get_allMaps()[wwt.inst.ctl.getCurrentReferenceFrame()];
  if (rootlm) {
    // all we need is the .layers part of a LayerMap
    accum(rootlm as LayerMap);
  }
  return layers;
}


export function activeLayersList(wwt: WWTGlobalState): string[] {
  if (wwt.inst === null)
    throw new Error('cannot get activeLayersList without linking to WWTInstance');

  const layers: string[] = [];

  function accum(lm: LayerMap) {
    for (const layer of lm.layers) {
      layers.push(layer.id.toString());
    }
    
    for (const [_mapname, sublm] of Object.entries(lm.childMaps)) {
      accum(sublm);
    }
  }

  // const rootlm = wwt.inst.lm.get_allMaps()[wwt.inst.ctl.getCurrentReferenceFrame()];
  for (const key of Object.keys(wwt.inst.lm.get_allMaps())) {
    const rootlm = wwt.inst.lm.get_allMaps()[key];
    if (rootlm) {
      // all we need is the .layers part of a LayerMap
      accum(rootlm as LayerMap);
    }
  }
  return layers;
}

/**
 * Generated by Copilot
 * 
 * ORBIT COORDINATE FIX STATUS:
 * 
 * The WWT engine's orbit.js draw3D method has been fixed at the source.
 * The old code incorrectly applied the Y↔Z swap (_orbitalToWwt) on the 
 * wrong side of the matrix multiplication, causing ~90° rotation errors.
 * 
 * The fix uses the basis vector approach (matching what planets.js does):
 * 1. Compute perihelion direction P = Rz(Ω) × Rx(i) × Rz(ω) × (1,0,0) in standard ecliptic
 * 2. Compute orbital pole H = Rz(Ω) × Rx(i) × (0,0,1) in standard ecliptic
 * 3. Compute in-plane perpendicular Q = H × P
 * 4. Build orientation matrix with Y↔Z swap for each basis vector
 * 
 * This patch function is no longer needed if using the fixed engine.
 * Keeping it here for reference/fallback.
 */
export function patchOrbitCoordinates(): boolean {
  // The engine has been fixed at the source (engine/esm/layers/orbit.js).
  // This patch is no longer needed.
  console.log("✓ patchOrbitCoordinates: Engine fix is in orbit.js - no runtime patch needed");
  return true;
}


// debug stuff
import {
  Colors,
  Coordinates,
  Matrix3d,
  // @ts-ignore
  SimpleLineList,
  SpaceTimeController,
  Vector3d,
  // @ts-ignore
  WWTControl,
} from "@wwtelescope/engine";

let axisX: SimpleLineList | null = null;
let axisY: SimpleLineList | null = null;
let axisZ: SimpleLineList | null = null;

function buildAxes(length = 1, alignEcliptic = false) {
  // @ts-ignore meanObliquityOfEcliptic is on Coordinates
  const obliquityDeg = alignEcliptic ? Coordinates.meanObliquityOfEcliptic(SpaceTimeController.get_jNow()) : 0;
  const mat = alignEcliptic
    ? Matrix3d._rotationX(-(obliquityDeg * Math.PI) / 180)
    : null;

  const makeAxis = (a: Vector3d, b: Vector3d) => {
    const list = new SimpleLineList();
    list.set_depthBuffered(false); // set true if you want depth testing
    if (mat) {
      // @ts-ignore
      a = Vector3d._transformCoordinate(a, mat);
      // @ts-ignore
      b = Vector3d._transformCoordinate(b, mat);
    }
    list.addLine(a, b);
    return list;
  };

  axisX = makeAxis(Vector3d.create(-length, 0, 0), Vector3d.create(length, 0, 0));
  axisY = makeAxis(Vector3d.create(0, -length, 0), Vector3d.create(0, length, 0));
  axisZ = makeAxis(Vector3d.create(0, 0, -length), Vector3d.create(0, 0, length));
}


export function addDebugLines() {
  buildAxes(10, false);
  addToWWTRenderLoop(() => {
    const rc = WWTControl.singleton.renderContext;
    axisX?.drawLines(rc, 1, Colors.get_red());
    axisY?.drawLines(rc, 1, Colors.get_green());
    axisZ?.drawLines(rc, 1, Colors.get_blue());
  });
};
