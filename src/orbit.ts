// Generated by Copilot
import type { EOE } from "@wwtelescope/engine";
import { AU_KM } from "./constants";

export function wrap360Degrees(value: number): number {
  const wrapped = value % 360;
  return wrapped < 0 ? wrapped + 360 : wrapped;
}

export function degreesToRadians(value: number): number {
  return (value * Math.PI) / 180;
}

export function radiansToDegrees(value: number): number {
  return (value * 180) / Math.PI;
}

export function normalizeSemiMajorAxisToKm(a: number): number {
  if (Math.abs(a) < 1e4) {
    return a * AU_KM; // likely AU
  }
  if (Math.abs(a) > 1e9) {
    return a / 1000; // likely meters
  }
  return a; // assume already in km
}

export function computeEccentricAnomaly(meanAnomalyRad: number, eccentricity: number, steps = 5): number {
  let eccentricAnomaly = meanAnomalyRad;
  for (let i = 0; i < steps; i++) {
    eccentricAnomaly += (meanAnomalyRad - eccentricAnomaly + eccentricity * Math.sin(eccentricAnomaly)) / (1 - eccentricity * Math.cos(eccentricAnomaly));
  }
  return eccentricAnomaly;
}

export function computeTrueAnomaly(eccentricAnomalyRad: number, eccentricity: number): number {
  const num = Math.sqrt(1 + eccentricity) * Math.sin(eccentricAnomalyRad / 2);
  const den = Math.sqrt(1 - eccentricity) * Math.cos(eccentricAnomalyRad / 2);
  return 2 * Math.atan2(num, den);
}

export interface PropagatedOrbit {
  meanAnomalyDeg: number;
  eccentricAnomalyRad: number;
  eccentricAnomalyDeg: number;
  trueAnomalyRad: number;
  trueAnomalyDeg: number;
}

// Matches the mean anomaly advancement used in Orbit.draw3D inside @wwtelescope/engine
export function meanAnomalyDegAtDate(elements: EOE, jd: number): number {
  const deltaDays = jd - elements.t;
  const raw = elements.n * deltaDays;
  const sign = raw < 0 ? -1 : 1;
  const normalized = Math.abs(raw) / 360;
  const frac = normalized - Math.trunc(normalized);
  const advanced = frac * 360 * sign;
  return wrap360Degrees(advanced);
}

export function propagateOrbitElements(elements: EOE, jd: number): PropagatedOrbit {
  const meanAnomalyDeg = meanAnomalyDegAtDate(elements, jd);
  const meanAnomalyRad = degreesToRadians(meanAnomalyDeg);
  const eccentricAnomalyRad = computeEccentricAnomaly(meanAnomalyRad, elements.e);
  const eccentricAnomalyDeg = wrap360Degrees(radiansToDegrees(eccentricAnomalyRad));
  const trueAnomalyRad = computeTrueAnomaly(eccentricAnomalyRad, elements.e);
  const trueAnomalyDeg = wrap360Degrees(radiansToDegrees(trueAnomalyRad));
  return {
    meanAnomalyDeg,
    eccentricAnomalyRad,
    eccentricAnomalyDeg,
    trueAnomalyRad,
    trueAnomalyDeg,
  };
}
/* eslint-disable @typescript-eslint/naming-convention */
export interface HorizonsLikeRow {
  JDTDB: number;
  EC: number;
  QR: number;
  IN: number;
  OM: number;
  W: number;
  Tp: number;
  N: number;
  MA: number;
  TA: number;
  A: number;
  AD: number;
  PR: number;
  E: number;
}
export function horizonsRowFromElements(elements: EOE, jd: number): HorizonsLikeRow {
  const aKm = normalizeSemiMajorAxisToKm(elements.a);
  const ec = elements.e;
  const qr = aKm * (1 - ec);
  const ad = aKm * (1 + ec);
  const meanMotionDegPerDay = elements.n;
  const meanMotionDegPerSec = meanMotionDegPerDay / 86_400;

  const propagated = propagateOrbitElements(elements, jd);

  const periodSeconds = meanMotionDegPerSec === 0 ? Number.POSITIVE_INFINITY : (360 / meanMotionDegPerSec);

  return {
    JDTDB: jd,
    EC: ec,
    QR: qr,
    IN: elements.i,
    OM: elements.omega,
    W: elements.w,
    Tp: elements.t,
    N: meanMotionDegPerSec,
    MA: propagated.meanAnomalyDeg,
    TA: propagated.trueAnomalyDeg,
    A: aKm,
    AD: ad,
    PR: periodSeconds,
    E: propagated.eccentricAnomalyDeg,
  };
}

export function formatScientific(value: number, digits = 15): string {
  return value.toExponential(digits).replace('e', 'E');
}

export function formatJulianDate(jd: number, digits = 9): string {
  return jd.toFixed(digits);
}

export function formatHorizonsBlock(row: HorizonsLikeRow): string[] {
  return [
    `EC= ${formatScientific(row.EC)} QR= ${formatScientific(row.QR)} IN= ${formatScientific(row.IN)}`,
    ` OM= ${formatScientific(row.OM)} W = ${formatScientific(row.W)} Tp= ${formatJulianDate(row.Tp)}`,
    ` N = ${formatScientific(row.N)} MA= ${formatScientific(row.MA)} TA= ${formatScientific(row.TA)}`,
    ` A = ${formatScientific(row.A)} AD= ${formatScientific(row.AD)} PR= ${formatScientific(row.PR)}`,
  ];
}
export function parseHorizonsText(raw: string): HorizonsLikeRow[] {
  const lines = raw.split(/\r?\n/);
  const rows: HorizonsLikeRow[] = [];

  for (let i = 0; i < lines.length; i++) {
    const jdMatch = lines[i]?.match(/^\s*(\d+\.\d+)\s*=/);
    if (!jdMatch || !jdMatch[1]) continue;
    const jd = parseFloat(jdMatch[1]);
    const l1 = lines[i + 1] ?? "";
    const l2 = lines[i + 2] ?? "";
    const l3 = lines[i + 3] ?? "";
    const l4 = lines[i + 4] ?? "";

    const ec = parseFloat(l1.match(/EC=\s*([\d.E+-]+)/)?.[1] ?? "NaN");
    const qr = parseFloat(l1.match(/QR=\s*([\d.E+-]+)/)?.[1] ?? "NaN");
    const inc = parseFloat(l1.match(/IN=\s*([\d.E+-]+)/)?.[1] ?? "NaN");

    const om = parseFloat(l2.match(/OM=\s*([\d.E+-]+)/)?.[1] ?? "NaN");
    const w = parseFloat(l2.match(/W\s*=\s*([\d.E+-]+)/)?.[1] ?? "NaN");
    const tp = parseFloat(l2.match(/Tp=\s*([\d.E+-]+)/)?.[1] ?? "NaN");

    const n = parseFloat(l3.match(/N\s*=\s*([\d.E+-]+)/)?.[1] ?? "NaN");
    const ma = parseFloat(l3.match(/MA=\s*([\d.E+-]+)/)?.[1] ?? "NaN");
    const ta = parseFloat(l3.match(/TA=\s*([\d.E+-]+)/)?.[1] ?? "NaN");

    const a = parseFloat(l4.match(/A\s*=\s*([\d.E+-]+)/)?.[1] ?? "NaN");
    const ad = parseFloat(l4.match(/AD=\s*([\d.E+-]+)/)?.[1] ?? "NaN");
    const pr = parseFloat(l4.match(/PR=\s*([\d.E+-]+)/)?.[1] ?? "NaN");

    if (Number.isNaN(jd) || Number.isNaN(ec)) {
      continue;
    }

    const row: HorizonsLikeRow = {
      JDTDB: jd,
      EC: ec,
      QR: qr,
      IN: inc,
      OM: om,
      W: w,
      Tp: tp,
      N: n,
      MA: ma,
      TA: ta,
      A: a,
      AD: ad,
      PR: pr,
      E: ma, // placeholder, overwrite below
    };
    row.E = row.MA; // keep Kepler form even if not supplied
    rows.push(row);
  }

  return rows;
}

export function diffHorizonsRows(a: HorizonsLikeRow, b: HorizonsLikeRow): HorizonsLikeRow {
  const pct = (x: number, y: number): number => {
    if (Math.abs(y) < 1e-20) return 0;
    return ((x - y) / y) * 100;
  };

  const diff = { ...a } as HorizonsLikeRow;
  diff.JDTDB = a.JDTDB;
  diff.EC = pct(a.EC, b.EC);
  diff.QR = pct(a.QR, b.QR);
  diff.IN = pct(a.IN, b.IN);
  diff.OM = pct(a.OM, b.OM);
  diff.W = pct(a.W, b.W);
  diff.Tp = pct(a.Tp, b.Tp);
  diff.N = pct(a.N, b.N);
  diff.MA = pct(a.MA, b.MA);
  diff.TA = pct(a.TA, b.TA);
  diff.A = pct(a.A, b.A);
  diff.AD = pct(a.AD, b.AD);
  diff.PR = pct(a.PR, b.PR);
  diff.E = pct(a.E, b.E);
  return diff;
}
/* eslint-enable @typescript-eslint/naming-convention */
